[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Decision Tree Alternative Visualization",
    "section": "",
    "text": "1 Introduction\nConventional decision trees visualizations – complete with nodes, branches, and leaves – are an invaluable tool in statistical modeling. They help us understand regression “splits” (that is, how data is partitioned based on independent variables) and make predictions about new, unseen data. In other words, decision trees are an effective way to take a data point and follow a sequence of decision rules (thus creating the “tree” shape) to ultimately arrive at a predicted value for the outcome variable. But decision tree plots aren’t the only way that we could, or should, visualize how a model makes regression decisions.\nIndeed, the classic decision tree has some interpretability challenges inherent in the node and branch structure. Particularly when the decision trees are wide and deep, these visualizations can be tricky to follow and (ultimately) make predictions off of. When we have two (non-binary) predictor variables, we can create an alternative visualization that basically maps the individual decision splits directly onto a predictor space with two variables – one predictor on the x-axis and another on the y-axis – so that we can see how and where the decision tree partitions the data:\n\n\n\nDecision tree alternative visualization by Prof. Robbins\n\n\nMore specifically, the space is divided into rectangular regions according to the splits made by the tree – with each region corresponding to a terminal node (or leaf) of a decision tree and is labeled with the predicted value assigned to that region. The vertical and horizontal lines show the values at which the model splits the data.\nAs we can see, the practical utility of this visual is that if we have the value of two predictors (in this case years playing baseball and number of hits), we can simply find what rectangular region that specific combination of predictors is in. The label of the rectangular region (in this example, the log salary of the player) is our prediction. The benefit of this visualization method is that it provides an immediate and (in my opinion, at least) more intuitive understanding of how the regression model actually segments the predictor space, making it more straightforward to apply the model to make predictions about new data, without having to trace through a complex tree.\nHowever, the reason that this sample visualization was hand drawn (rather than done digitally in R) is because, according to Professor Robbins, there really isn’t a simple, straightforward way to make these visualizations in R. My final project is an attempt to address that issue. To that end, I’ll be motivated by the following research question: how can we use R to design an alternative regression model visualization that takes information typically used to build a traditional decision tree and instead use it to automatically create a visualization that maps decision splits directly onto a predictor space?\nThe majority of this project will focus on programming the function in R that digitally creates this visualization. To do this, I intend to use ggplot functions as well as the model results that come from the rpart function (the same function that helps us to create the traditional decision trees). If this part is successful, I’ll potentially attempt to extend this project further by creating my own package in R which contains my visualization function (though, again, this is more aspirational). The final paper will include an in-depth description of the research question at hand and my method for creating the visualization function (that is, specifically addressing how I wrote the R code). For the results section, I’ll provide the R code for the function and illustrate its usage with sample data. Finally, in the conclusion, I’ll include a more general discussion of the alternative visualization method and reflections on the process of writing my function that creates it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "2  Methods",
    "section": "",
    "text": "2.1 Code\nCode\nlibrary(ISLR2)\nlibrary(rpart)\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(rpart.plot)\n\nHitters &lt;- Hitters |&gt;\n  filter(!is.na(Salary)) |&gt;\n  mutate(Logsal = log(Salary))\nHitters |&gt; select(Years, Hits, Division, AtBat, Logsal) |&gt;\n  head(15)\n\n\n                  Years Hits Division AtBat   Logsal\n-Alan Ashby          14   81        W   315 6.163315\n-Alvin Davis          3  130        W   479 6.173786\n-Andre Dawson        11  141        E   496 6.214608\n-Andres Galarraga     2   87        E   321 4.516339\n-Alfredo Griffin     11  169        W   594 6.620073\n-Al Newman            2   37        E   185 4.248495\n-Argenis Salazar      3   73        W   298 4.605170\n-Andres Thomas        2   81        W   323 4.317488\n-Andre Thornton      13   92        E   401 7.003065\n-Alan Trammell       10  159        E   574 6.248319\n-Alex Trevino         9   53        W   202 6.239301\n-Andy VanSlyke        4  113        E   418 6.309918\n-Alan Wiggins         6   60        E   239 6.551080\n-Bill Almon          13   43        E   196 5.480639\n-Buddy Bell          15  158        W   568 6.652863\n\n\nCode\ndata(mtcars)\ndata(airquality)\n\nmod1 &lt;- rpart(Logsal ~ Hits + Years, data = Hitters, cp = 0.01)\nmod2 &lt;- rpart(mpg ~ hp + wt, data = mtcars, cp = 0.01)\nmod3 &lt;- rpart(Ozone ~ Wind + Temp, data = airquality, cp = 0.01)\n\nalt_viz &lt;- function(mod, type = 1) {\n  names &lt;- unique(mod$frame$var)\n  names &lt;- names[names != \"&lt;leaf&gt;\"]\n  \n  if (length(names) == 1) {\n    xname &lt;- names[1]\n    yname &lt;- NULL\n  } else {\n    yname &lt;- names[1]\n    xname &lt;- names[2]\n  }\n  \n  modelname &lt;- mod$call$data\n  leaf &lt;- rownames(mod$frame[mod$frame$var == \"&lt;leaf&gt;\", ])\n  paths &lt;- path.rpart(mod, nodes = leaf, print.it = FALSE)\n  \n  get_bounds &lt;- function(conditions) {\n    data &lt;- get(modelname)\n    xvals &lt;- data[[xname]]\n    \n    if (!is.null(yname)) {\n      yvals &lt;- data[[yname]]\n    } else {\n      yvals &lt;- rep(1, length(xvals))\n    }\n    \n    x_min &lt;- ifelse(min(xvals) &gt;= 0, 0, min(xvals)) ; x_max &lt;- max(xvals)\n    y_min &lt;- ifelse(min(yvals) &gt;= 0, 0, min(yvals)) ; y_max &lt;- max(yvals)\n    \n    for (i in conditions) {\n      i &lt;- gsub(\" \", \"\", i)\n      if (grepl(paste0(\"^\", xname, \"&lt;\"), i)) x_max &lt;- round(min(x_max, as.numeric(sub(paste0(xname, \"&lt;\"), \"\", i))), 1)\n      if (grepl(paste0(\"^\", xname, \"&gt;=\"), i)) x_min &lt;- round(max(x_min, as.numeric(sub(paste0(xname, \"&gt;=\"), \"\", i))), 1)\n      if (!is.null(yname)) {\n        if (grepl(paste0(\"^\", yname, \"&lt;\"), i)) y_max &lt;- round(min(y_max, as.numeric(sub(paste0(yname, \"&lt;\"), \"\", i))), 1)\n        if (grepl(paste0(\"^\", yname, \"&gt;=\"), i)) y_min &lt;- round(max(y_min, as.numeric(sub(paste0(yname, \"&gt;=\"), \"\", i))), 1)\n      }\n    }\n    return(c(x_min, x_max, y_min, y_max))\n  }\n  \n  bounds_list &lt;- lapply(paths, get_bounds)\n  bounds_df &lt;- as.data.frame(do.call(rbind, bounds_list))\n  colnames(bounds_df) &lt;- c(\"xmin\", \"xmax\", \"ymin\", \"ymax\")\n  \n  leaf_preds &lt;- mod$frame[mod$frame$var == \"&lt;leaf&gt;\", \"yval\"]\n  regions &lt;- bounds_df |&gt; mutate(pred = round(leaf_preds, 1)) |&gt; tibble()\n  \n  plot &lt;- ggplot(regions) +\n    geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = pred), color = \"black\", alpha = 0.5) +\n    geom_text(aes(x = (xmin + xmax)/2, y = (ymin + ymax)/2, label = pred), size = 3.5) +\n    labs(x = xname, y = ifelse(is.null(yname), \"\", yname)) +\n    theme_minimal() +\n    theme(legend.position = \"none\")\n  \n  if (type == 1) {\n    print(plot)\n  } else if (type == 2) {\n    print(regions)\n  } else if (type == 3) {\n    print(plot); print(regions)\n  } else {\n    stop(\"Invalid `type` argument. Must be 1 (plot), 2 (data), or 3 (both).\")\n  }\n}\n\nalt_viz(mod1)\n\n\n\n\n\n\n\n\n\nCode\nalt_viz(mod2)\n\n\n\n\n\n\n\n\n\nCode\nalt_viz(mod3)\n\n\n\n\n\n\n\n\n\nCode\nrpart.plot(mod1)\n\n\n\n\n\n\n\n\n\nCode\nrpart.plot(mod2)\n\n\n\n\n\n\n\n\n\nCode\nrpart.plot(mod3)\n\n\n\n\n\n\n\n\n\nCode\n# what to do when we have a binary variable\n# alt_viz(rpart(Logsal ~ Hits + Division, data = Hitters, cp = 0.01))\n# what to do when we have more than 2 variables\n# alt_viz(rpart(Ozone ~ Wind + Temp + Solar.R, data = airquality, cp = 0.01))\n# what to do when only one variable is important for splits\nalt_viz(rpart(mpg ~ hp + qsec, data = mtcars, cp = 0.01))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Methods</span>"
    ]
  }
]